function twotap_analysis
% purpose: analysing the data from the twotap task just like actual
% behavioral task

% detect pairs of "taps". these are trials
% taps are either defining IPI or ITI

%% find all actions, then sort into ITI or IPI

%% plots of ITI vs trials
[results_intact,results_lesioned]=twotap_world;

[tap_idx]=find(results_intact.action == 2);

tap_idx = [tap_idx tap_idx(end)+1];
dur_tap = diff(tap_idx); %tells you how much time between each tap, but not whether the tap was IPI or ITI

IPI_start = tap_idx(results_intact.l_state(tap_idx)== 26); %index (timepoint) of when IPI started
IPI_end = tap_idx(find(results_intact.l_state(tap_idx)== 26)+1); %index timepoint of IPI end
IPI=((IPI_end-IPI_start)*100)./1000;

ITI_start=tap_idx(results_intact.c_state(tap_idx)== 14); %index (timepoint) of when ITI started
ITI_end = tap_idx(find(results_intact.c_state(tap_idx)== 14)+1); %index timepoint of IPI end
ITI=((ITI_end-ITI_start)*100)./1000;

[a,idx]=sort([ITI_start IPI_start]);
ALL_int=[ITI IPI];

for i = 1:length(ALL_int)
    % basically look at whether the next thing is an IPI or ITI (really
    % dumb way to do things)
    if idx(i)< length(ITI)
        ITI_final(i) = ALL_int(idx(i));
        IPI_final(i) = NaN;
    else
        ITI_final(i) = NaN;
        IPI_final(i) = ALL_int(idx(i));
    end
end

figure; hold on;
subplot 211
plot(IPI_final,'o')
line([0 ])
subplot 212
plot(ITI_final,'o')
% find taps that are starts of IPI's

[success]=find(results_intact.observe(tap_idx+1)== 2);

[idx]=find(results_intact.state == 14);
ITI = (diff(idx)*100)./1000;

figure;plot(ITI)
%find() %find transitions between state 7 and 26
%plot those transitions 
end